
--------------------------------
Sequential skiplist
--------------------------------
Sequential Skip List Implementation

The sequential skip list is a probabilistic data structure designed for efficient single-threaded operations, offering logarithmic average time complexity for search, insertion, and deletion. It organizes elements hierarchically across multiple levels, where higher levels provide shortcuts to nodes in the lower levels, reducing traversal time.
Key Features:

    Node Structure:
        Each node contains a key and an array of pointers (next), one for each level the node spans.
        A special head node, initialized with pointers for all levels set to NULL, acts as the starting point.

    Initialization:
        The skip list is configured with a fixed number of levels and a promotion probability (prob), which determines the likelihood of a node being promoted to higher levels.
        A random seed ensures consistent behavior for level assignment during debugging or repeated runs.

    Search Operation:
        The search starts at the topmost level of the head node and moves horizontally across nodes until the target key is located or surpassed.
        If further progress is blocked at a level, the algorithm drops down to the next level and continues the traversal.

    Insertion Operation:
        A new node’s levels are determined probabilistically using the promotion probability.
        The skip list is traversed to identify the appropriate positions at each level, and the next pointers of the preceding nodes are updated to include the new node.

    Deletion Operation:
        The deletion algorithm traverses the skip list to locate the target node.
        It updates the next pointers of the preceding nodes at each level to bypass the node, effectively removing it from the structure.

Probabilistic Level Assignment:

    The probability factor ensures that higher levels contain fewer nodes, balancing the skip list’s height and minimizing search path lengths.

--------------------------------------------------------
LOCK-FREE SKIPLIST
--------------------------------------------------------
Skip list implementation design
At the heart of this implementation lies the extensive use of atomic operations, thread coordination strategies, and a carefully crafted design that ensures progress and consistency.
Atomic operations are the cornerstone of the lock-free skip list, enabling thread-safe updates to shared variables. The __atomic_compare_exchange primitive (CAS) plays a critical role. It allows threads to compare the current value of a variable with an expected value and update it only if the two match, ensuring that updates are atomic and consistent. This mechanism is widely used to modify pointers during operations like insertion or deletion. Alongside CAS, other atomic primitives, such as __atomic_fetch_add and __atomic_fetch_sub, are employed for incrementing or decrementing counters. These operations, combined with atomic load and store functions, ensure that threads can access and update shared variables without race conditions. All these operations are configured with relaxed memory ordering (__ATOMIC_RELAXED), which optimizes performance by reducing synchronization overhead while maintaining the correctness of the data structure.
Thread coordination in the skip list is achieved through non-blocking mechanisms. The implementation uses sched_yield() to allow a thread to relinquish its execution time when it detects contention, enabling other threads to proceed. This approach minimizes busy-waiting and promotes fairness among threads. When CAS operations fail due to concurrent modifications, the skip list relies on retry logic, where threads reattempt the operation using the updated state of the data structure. This contention-handling strategy ensures that operations eventually succeed without blocking other threads.
Moreover, each node in the skip list maintains an array of pointers corresponding to its levels. Updates to these pointers are performed level-by-level, limiting the scope of contention and allowing threads to work independently on different parts of the structure.
In addition, all critical updates to pointers or node states are performed using CAS. In order to handle deletions safely, nodes are first marked as logically deleted before being physically removed. This prevents inconsistencies, as a node being traversed by one thread might simultaneously be targeted for deletion by another. This two-step deletion process, combined with atomic pointer updates, ensures that the structure remains consistent and robust.
