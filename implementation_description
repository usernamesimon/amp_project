
--------------------------------
SEQUENTIAL SKIPLIST IMPLEMENTATION DESIGN
--------------------------------
The node structure in the skip list is designed to enable efficient traversal and operations within an ordered list. Each node consists of a key, which serves as the value or identifier for ordering and searching, and a dynamically allocated array of pointers. These pointers connect to subsequent nodes at different levels, allowing the skip list to skip over sections of the list and perform operations more quickly.
The skip listâ€™s implementation revolves around the principles of multi-level linking and probabilistic balancing. Nodes are connected at various levels, with higher levels acting as shortcuts for fast traversal. The height of a node, which determines the number of levels it participates in, is assigned probabilistically using a random number generator. The implementation relies on the drand48 family of functions for this purpose, ensuring that node heights are distributed according to the specified probability factor. To maintain consistent and reproducible behavior, a random_state structure is used to manage the state of the random number generator. During initialization, the srand48_r function is called with a user-specified seed to set up this random state, and the drand48_r function is subsequently used to generate random numbers during operations such as node height determination.
Core operations in the skip list include search, insertion, and deletion. Searches begin at the highest level of the list and proceed downward, skipping over unnecessary nodes to quickly locate the desired key. Insertions involve creating a new node with a height determined probabilistically using drand48_r, then linking the node at the appropriate levels while preserving the structure of the list. Deletions are handled by unlinking nodes from all levels they participate in, ensuring that the skip list remains consistent and orderly.

--------------------------------------------------------
LOCK-FREE SKIPLIST IMPLEMENTATION DESIGN
--------------------------------------------------------
At the heart of this implementation lies the extensive use of atomic operations, thread coordination strategies, and a carefully crafted design that ensures progress and consistency.
Atomic operations are the cornerstone of the lock-free skip list, enabling thread-safe updates to shared variables. The __atomic_compare_exchange primitive (CAS) plays a critical role. It allows threads to compare the current value of a variable with an expected value and update it only if the two match, ensuring that updates are atomic and consistent. This mechanism is widely used to modify pointers during operations like insertion or deletion. Alongside CAS, other atomic primitives, such as __atomic_fetch_add and __atomic_fetch_sub, are employed for incrementing or decrementing counters. These operations, combined with atomic load and store functions, ensure that threads can access and update shared variables without race conditions. All these operations are configured with relaxed memory ordering (__ATOMIC_RELAXED), which optimizes performance by reducing synchronization overhead while maintaining the correctness of the data structure.
Thread coordination in the skip list is achieved through non-blocking mechanisms. The implementation uses sched_yield() to allow a thread to relinquish its execution time when it detects contention, enabling other threads to proceed. This approach minimizes busy-waiting and promotes fairness among threads. When CAS operations fail due to concurrent modifications, the skip list relies on retry logic, where threads reattempt the operation using the updated state of the data structure. This contention-handling strategy ensures that operations eventually succeed without blocking other threads.
Moreover, each node in the skip list maintains an array of pointers corresponding to its levels. Updates to these pointers are performed level-by-level, limiting the scope of contention and allowing threads to work independently on different parts of the structure.
In addition, all critical updates to pointers or node states are performed using CAS. In order to handle deletions safely, nodes are first marked as logically deleted before being physically removed. This prevents inconsistencies, as a node being traversed by one thread might simultaneously be targeted for deletion by another. This two-step deletion process, combined with atomic pointer updates, ensures that the structure remains consistent and robust.
